<html>
	<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<title>Yake Coding Guidelines</title>
		<style type="text/css">
			body, td, th, h1, h2, h3, h4, h5
			{
				font-family : Verdana;
				font-size : 9pt;
				font-weight : normal;
				color : black;
			}

			.all
			{
				background-color : black;
			}

			.menu a.current:link, .menu a.current:active, .menu a.current:visited, .menu a.current:hover
			{
				color : White;
			}

			a:link, a:active, a:visited
			{
				color : black;
				font-weight : bold;
				text-decoration : underline;
			}

			a:hover
			{
				text-decoration : none;
			}

			th
			{
				background-color : black;
				color : white;
			}

			h1
			{
				font-size : 12pt;
				font-weight : bold;
				text-align : center;
			}

			h2
			{
				font-size : 10pt;
				font-weight : bold;
			}

			.header
			{
				color : white;
				background-color : black;
				font-size : 20pt;
			}

			.footer
			{
				text-align : center;
			}

			.menu, .footer
			{
				background-color : black;
				color : white;
			}

			.menu a:link, .menu a:active, .menu a:visited, .footer a:link, .footer a:active, .footer a:visited
			{
				color : white;
				text-decoration : none;
			}

			.menu a:hover, .footer a:hover
			{
				text-decoration : underline;
			}
		</style>
	</head>
	<body leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
		<table border="0" cellspacing="0" cellpadding="3" width="100%" height="100%" class="all">
			<tr>
				<td width="100%" height="80" class="header">
				Yake::Convention
				</td>
			</tr>
			<tr>
				<td width="100%" height="20" class="menu">
					<a href="CodingConvention.html" class="current">Physical Organization</a>
					&nbsp;|&nbsp;
					<a href="CodingConvention2.html">Logical Organization</a>
				</td>
			</tr>
			<tr>
				<td width="100%" valign="top" bgcolor="white">
					<table border="0" cellspacing="0" cellpadding="5" width="100%" height="100%">
						<tr>
							<td valign="top">
								<h1>Logical Organization</h1>


								<h2>General</h2>

								<ol>
									<li>
									    Avoid global functions and variables. Possible alternatives are singletons,
									    classes with static member functions etc.
									</li>
								</ol>

								<h2>Classes</h2>

								<ol>
								    <li>
								        Never specifiy member variables in the <code>public</code> or
								        <code>protected</code> section of a class. The former reveals implementation
								        details to the user of the class, the latter reveals implementation details
								        to any derivative, i.e. both add dependencies between client code and the class.
								    </li>

								    <li>
								        Accessor and forwarder functions might be inlined in order to improve
								        performance.
								    </li>

								    <li>
								        Constructors and destructors generally shouldn't be inlined. Exception:
								        The virtual member function in an interface (abstract class) has to be
								        empty and inlined in order to assure correct destruction of derivates.
								    </li>

								    <li>
								        Generally, friend declarations should be avoided.
								    </li>

								    <li>
								        A member function that doesn't affect the state of its object (i.e. its
								        instance variables) is to be declared <code>const</code>.
								    </li>

								    <li>
								        Usually one should declare default constructor, copy constructor,
								        assignment operator and destructor. Exception: This isn't necessarily true
								        for simpler classes and structures, where the default constructors/operators
								        do their job.
								    </li>

								    <li>
								        If a class is used as a base class, it has to provide a virtual destructor.
								    </li>

								    <li>
								        Use operator overloading only when appropriate, for instance for primitive
								        math classes like Vector or Quaternion. Don't use operator overloading when
								        it might lead to misunderstanding.
								    </li>

								    <li>
								        A public member function must never return a non-const reference or pointer
								        to a member variable, for the same reason that member variables shouldn't
								        be public.
								    </li>

								    <li>
								        Only use inheritance for "is-a" relationships.
								    </li>
								</ol>

								<h2>Functions</h2>

								<ol>
								    <li>
                                        Try to avoid unspecified function arguments (i.e. the "..." ellipsis
                                        notation).
								    </li>

								    <li>
								        Avoid functions with many arguments.
								    </li>

								    <li>
								        Unless passing primitive types or pointers, use constant references instead
								        of call-by-value arguments.
								    </li>

								    <li>
								        When overloading functions, each variation should have the same semantics,
								        i.e. it should be used for the same purpose.
								    </li>

								    <li>
								        Use inline functions instead of #definitions to improve performance.
								    </li>

								    <li>
								        Avoid temporary objects created as return values from functions or as
								        arguments to functions. Instead, use references.
								    </li>

								    <li>
								        Generally, avoid long functions. Refactor them in multiple functions
								        instead.
								    </li>
								</ol>

								<h2>Constants</h2>

								<ol>
								    <li>
									    Never create constants using #define. Instead, use <code>const</code> or
									    enumerations.
								    </li>
								</ol>

								<h2>Variables</h2>

								<ol>
								    <li>
									    Variables are to be declared with the smallest possible scope.
								    </li>

								    <li>
									    Each variable is to be declared in a separate declaration statement.
								    </li>

								    <li>
									    Every variable is to be initialized before usage.
								    </li>

								    <li>
								        Initialization is to be prefered over assignment. Example:

								        <pre><code>int i = calculateNumber();</code></pre>

								        is to be prefered over:

								        <pre><code>int i;
i = calculateNumber();
                                        </code></pre>
								    </li>
								</ol>

								<h2>Pointers and references</h2>

								<ol>
								    <li>
								        Don't use NULL. Use 0 instead.
								    </li>

								    <li>
								        If a null pointer is invalid in the context, use references instead.
								    </li>
								</ol>

								<h2>Type conversions</h2>

								<ol>
								    <li>
								        Never use explicit type conversions (casts).
								    </li>

								    <li>
								        Never use explicit type conversions using C-style casts. Instead, use
								        static_cast<>, const_cast<> or reinterprete_cast<> <u>only if
								        necessary</u>.
								    </li>

								    <li>
								        If a null pointer is invalid in the context, use references instead.
								    </li>
								</ol>

								<h2>Flow control structures</h2>

								<ol>
								    <li>
								        Code following a <code>case</code> label must always be terminated by either
								        a <code>break</code> or a <code>return</code> statement. Exception: Multiple
								        case labels might go into the same (!) codepath. So the following code snippet is
								        valid:

								        <pre><code>case ALPHA:
case BETA:
    DoCommonAction();
    break;
                                        </code></pre>

								        but the following is not:

								        <pre><code>// Don't do this!
case ALPHA:
    DoUncommonAction();

case BETA:
    DoCommonAction();
    break;
                                        </code></pre>
								    </li>

								    <li>
								        A <code>switch</code> statement must always contain a <code>default</code>
								        branch (even if it just throws an exception or <code>assert( false )</code>s).
								    </li>

								    <li>
								        Avoid using <code>goto</code>.
								    </li>

								    <li>
								        Avoid using <code>unsigned</code> variables.
								    </li>
								</ol>

								<h2>Expressions</h2>

								<ol>
								    <li>
								        Use parentheses to clarify the order of evaluation in expressions.
								    </li>
								</ol>

								<h2>Memory allocation</h2>

								<ol>
								    <li>
								        Never use malloc, realloc or free.
								    </li>

								    <li>
								        Generally, the allocator of memory is responsible for deallocating it
								        later.
								    </li>
								</ol>

								<h2>Exception handling</h2>

								<ol>
								    <li>
								        Use exceptions for critical errors only. Exceptions shouldn't be thrown
								        during normal program flow.
								    </li>
								</ol>

								<h2>Portability</h2>

								<ol>
								    <li>
								        Use the <code>(u)int(size)_t</code> types when needing fixed-size integers
								        (for instance for serialization).
								    </li>

									<li>
									    Take care of proper alignment of data. For instance, on 32-bit machines,
									    functions have to begin on an address that is divisable by 32. That's what
									    the ALIGN() macro is for.
									</li>

								    <li>
									    Platform-dependant code should be refactored into plugins implementing a
									    specific interface.
								    </li>

									<li>
									    Basic platform-dependant code (i.e. platform dependant code that can't
									    reside in plugins, for instance plugin-loading code) should be refactored
									    into functions declared in <code>Yake/Core/Native/Native.h</code>, implemented in
									    <code>Yake/Core/Native/&lt;Platform&gt;</code> and wrapped by a wrapper
									    class in Yake.Core.
									</li>
								</ol>

								<h2>Order of execution</h2>

								<ol>
								    <li>
								        Do not depend on the order of initialization. For instance, the order in
								        which the members of a class are initialized using the constructor
								        initialization syntax is compiler-dependant. Also, the order in which
								        static objects are initializated is compiler-dependant.
								    </li>
								</ol>
							</td>
						</tr>
					</table>
				</td>
			</tr>
				<td width="100%" height="20" class="footer">
				<a class="footer"></a>
				</td>
			</tr>
		</table>
	</body>
</html>