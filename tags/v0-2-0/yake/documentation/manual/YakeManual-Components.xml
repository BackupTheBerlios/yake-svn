<article>
	<title>yake::base</title>
	<articleinfo>
		<title>yake::base</title>
	</articleinfo>
	<section>
		<title>Overview</title>
		<para>Yake::base is, as the name implies, the basis for everything else that makes up Yake and Yapp.
		It provides functionality in a wide range of applications, from templates (Signals, Containers, meta programming helpers, factories etc) to
		common base interfaces (Movable etc) or data access (e.g. streams) and more.
		</para>
		<para>A few of the more complex concepts will be described in more depth as they are often used and/or essential for
		effective use of Yake. For example, abstract factory plugins.
		</para>
		<para>[TODO]
		</para>
	</section>
</article>
<article>
	<title>Components</title>
	<articleinfo>
		<title>Components</title>
	</articleinfo>
	<section>
		<title>Introduction and Design</title>
		<subtitle>What are components? And what part do they play in the whole?</subtitle>
		<para>Components are the core elements of Yake. Component loosely defines a collection of functionality.
		The concrete implementation can be very different. Many components are abstract components, i.e.
		they (additionally) provide abstract interfaces so that they are independent of underlying APIs.
		</para>
		<para>For example, the graphics component provides interfaces which have to be implemented for a specific
		API in order to be usable. Often these implementations reside in dynamic link libraries (i.e. a DLL on windows,
		.so on Linux). For example, the graphicsOGRE plugin is an implementation of the graphics interfaces
		using OGRE (Object-oriented Graphics Rendering Engine, http://www.ogre3d.org).
		</para>
	</section>
	<section>
		<title>yake::graphics /todo</title>
		<subtitle>Get seen!</subtitle>
	</section>
	<section>
		<title>yake::physics /todo</title>
	</section>
	<section>
		<title>yake::vfs /todo</title>
		<subtitle>Virtual File System</subtitle>
	</section>
	<section>
		<title>yake::data</title>
		<subtitle>Storage, Parsing, Interpreting</subtitle>
		<para>yake::data is mainly about parsing and interpreting. If you want to know more about data access or transfer please
		refer to the documentation of yake::vfs ( virtual file systems, local and remote ), yake::network or yake::base( for basic streams ).
		</para>
		<section>
			<title>DOM Serializer - yake::data::dom</title>
			<para>The DOM (Document Object Model) serializer interfaces allow serialization (reading/writing) of (typically hierarchically) structured data.
			</para>
			<section>
				<title>Storage format independence</title>
				<para>Concrete serializer implementations can provide different storage methods. For example,
				the yake::data::dom::xml::XmlSerializer provides the means to parse text based XML files.
				Other implementations may use a binary storage format or streamed data access.
				</para>
				<para>Of course, they can be implemented in plugins and registered to the serializer factory at runtime.
				</para>
				<para>Please refer to the Yake API documentation to find out more about the existing core serializers.
				</para>
			</section>
		</section>
		<section>
			<title>Parser - yake::data::parser</title>
			<para>Parsers create structured data for use with interpreters.
			</para>
			<para>For example, the DotSceneParser uses a DOM tree (see yake::data DOM Serializer) to read data using the
			dotScene description format. User applications can subscribe to signals and/or query the parser in order to
			create the graphical objects that represent the scene (see yake::graphics for more information on the graphics
			interfaces).
			</para>
		</section>
		<section>
			<title>Interpreter</title>
			<para>An interpreter is any kind of code that subscribes to a parser and creates concrete objects from the
			logic data provided by the parser.
			</para>
			<para>For example, a GraphicsSceneInterpreter may be used to actually create the graphical scene from the data
			provided by a dotSceneParser.
			</para>
		</section>
	</section>
	<section>
		<title>yake::scripting</title>
		<subtitle>Customization/Modding without recompiling your application!</subtitle>
		<section><title>Virtual Machines</title>
			<para>Virtual machines execute script code. In Yake they are represented by an abstract interface(yake::scripting::IVM)
			and they are created by scripting systems (yake::scripting::IScriptingSystem). For each scripting language there needs
			to be a specialized scripting system which is capable of creating specialized scripting objects (virtual machines and scripts).
			</para>
			<para>Generally it should be possible to create any number of virtual machines.
			</para>
		</section>
		<section><title>Scripts</title>
			<para>Scripts represent the scripting language dependent code that is fed to virtual machine to be executed >:)
			For example, for the Lua scripting virtual machines this can either represent source code or precompiled byte code.
			</para>
			<para>Possible script types (derived from yake::scripting::IScript) include procedural scripts
			(created from a string at runtime, for example) and scripts read from a data source (like from a file).
			</para>
		</section>
		<section><title>Binder</title>
			<para>The binder interface is used to bind objects, classes, functions, variables etc to a scripting virtual machine.
				The binder implementation decides what to bind (which classes, objects, free functions etc).
				There can be any amount of binders. The application logic has to decide when to use which binder, i.e. what features
				it wants to be bound to a specific VM. For example, the VM used to run GUI scripts may not need access to the physics system.
				Of course, that's just an example to illustrate the point.
			</para>
		</section>
	</section>
	<section>
		<title>yake::audio</title>
		<subtitle>Get heard!</subtitle>
		<para>The audio system is pretty straight-forward. Worlds are made up of sources, occluders and listeners.
		The exact feature set depends on the implementation (3D support, etc).
		</para>
		<para>Sources are any kind of audible objects. Listeners do what their name implies. They often represent the ears
		of the player in a game, for example.
		</para>
	</section>
</article>